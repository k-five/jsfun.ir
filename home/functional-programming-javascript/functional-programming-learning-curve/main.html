<main>
	<div class="content-r">
		<h1>functional-programming-learning-curve</h1>
        <hr>
        <p>My first experience with <strong>OOP</strong> happened with <strong>C++</strong>. Here is a simple code using OOP in C++.</p>
<pre><code class="language-javascript">class Foo;  // forward declaration of a class
 
class Bar { // definition of a class
  public:
    Bar(int i) : m_i(i) {}
  private:
    int m_i;
};
 
template &lt;class T&gt; // template argument
void qux() {
    T t;
}
 
int main()
{
    Bar Bar(1);
    class Bar Bar2(2); // elaborated type
}</code></pre>
        <p>After a while I told myself that I will become a master in C++, if  OOP is just these concepts and techniques!.</p>
        <p>I read the enter <a target="_blank" href="https://en.cppreference.com/w/">en.cppreference.com</a> website, printed all pages, and read them, code, and push more than <strong>2,200</strong> examples with C++ on my github page. <a target="_blnak" href="https://github.com/k-five/1000_examples_with_cpp">1000_examples_with_cpp</a>.</p>
        <p>I noticed as much as I go further, it becomes harder and harder to code in OOP style. It seemed messy and I could not go further easily.!</p>

        <h3 class="sub-title">Design Pattern</h3>
        <p>Yes, dealing with a large codebase, without any patterns or a kind of architecture, make the code messy! And the solution was by learning OOP's design patterns.</p>
        <p>So taking off with OOP is not challenging. You can simply create a class and add data and method to it and it works.</p>
        <p>But this is not true for functional programming. Why? Simple. Because without knowing many concepts at first you cannot start with FP. We first have to learn many things, which is tiring, then start to use very basic things, with is boring!</p>
        <p>For exampling learning</p>
        <ul>
            <li>Category Theory</li>
            <li>Set Theory</li>
            <li>Stateless and Stateful code</li>
            <li>Pure function and impure function</li>
            <li>Immutable data and mutable data</li>
            <li>Pipe and composition</li>
            <li>A log of small functions:</li>
            <ul>
                <li>map</li>
                <li>filter</li>
                <li>reduce</li>
                <li>take</li>
                <li>converge</li>
                <li>evolve</li>
                <li>identity</li>
                <li>etc</li>
            </ul>
            <li>Avoiding side effect</li>
            <li>Morphisms</li>
            <li>Functors</li>
            <li>Monads</li>
            <li>Closure</li>
            <li>Currying</li>
            <li>Partial application</li>
            <li>Memoiaztion</li>
            <li>etc</li>
        </ul>
        <p>Wait, wait. I do not want to learn these!</p>


        <h3 class="sub-title">From Windows and Linux</h3>
        <p>When I was using Windows XP2, then 3. and finally 8, and 10; I noticed for a simple task I had to install a program - usually crack it - and for next one, installing new ones!</p>
        <p>After a few months I had many installed programs and C drive was full. Solution? For really getting back and having a fresh OS, formatting the hard-disc and installing fresh!</p>
        <p>But ... I moved to Linux.</p>
        <p>I am a big fan of just using <strong>keyboard</strong> and not mouse. So quickly switching to <strong>Terminal</strong>. There is noting to do! A simple blinking cursor and that is it.</p>
        <p>There were more than 2,000+ commands (= CLIs). Who is going to learning them? How? Fortunately after a while, little by little and learning simple CLIs and how to combine them to solve more complex task, now I am able to solve complex tasks with a few commands just by <strong>piping</strong> them in just one line!</p>
        <p>Nnow I am very happen for migrating from Windows to Linux and sticking to Terminal and its way of using Terminal, having small CLIa that can be piped together to tackles more complex problems.</p>
        <p>And FP is the same. We will have a hard time learning many small functions and concepts and after a while; we will be really good at combing each of these and solve our problems.</p>


        <h3 class="sub-title">Fast versus Slow</h3>
        <p>With OOP we quickly can start coding. As we go forward - diving into larger code base - it becomes harder and harder - unless we learn Design Patterns well.</p>
        <p>With FP the opposite happens. We first have to learn its concepts and techniques then start to code. Very annoying at first, but very sweet ending :).</p>
        <p>Ready? Lets tackle some core concepts and techniques in FP from next posts, that we should grasp.</p>
		
        DD_MM_YYYY
        <div class="edit-on-github">
            <a target="_blank" href="https://github.com/k-five/jsfun.ir/blob/master/home/functional-programming-javascript/functional-programming-learning-curve/main.html">Edit on Github</a>
        </div>
	</div>
</main>
